---
title: Kubernates
type: docs
author: showa
lastmod: 2023-10-09T17:27:28+09:00
waight: 100800
---

## ローカルで動かすk8s

- [minikube](https://kubernetes.io/ja/docs/tutorials/hello-minikube/)
  - `minikube addons enable ingress -ingress`を有効化する
- [kind](https://kind.sigs.k8s.io/)

```yaml:k8s.yaml
# cluster 作成のコンフィグファイル
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
  role: control-plane
  role: worker
  role: worker
```

```bash
# clusterを作る --nameを指定しない場合、"kind"でつくられる
kind create cluster --config k8s.yaml
```

## KubernetesAPI

KubernetesはAPIを通じて操作している。cuiの`kubectl`はマスターノードの`kube-apiserver`に対して、yaml形式やjson形式のマニフェストを送信してオブジェクト（ポッド、コントローラ、サービスetc...）を操作する。

## Workload

ワークロードは、オブジェクトのカテゴリを表す用語として用いられ、コンテナとポッド、そして、コントローラのグループを指しています。これらは、アプリケーションやシステム機能を担うコンテナの実行を管理するために使用されます。  

- フロントエンド処理
- バックエンド処理
- バッチ処理
- システム運用処理

## Container

コンテナの起動に設定できる項目は、引数や環境変数、永続ボリュームのマウント先のパス、CPU使用時間やメモリ容量の要求量や上限値、ヘルスチェック方法、コンテナ起動時の実行コマンド、イメージ名などがあります。  

## Pod

コンテナを実行するためのオブジェクトです。ポッドは1つまたは複数のコンテナを内包しており、その構造が、エンドウ豆の鞘（さや）が豆を内包する様子と似ています。このことから、このオブジェクトは鞘を意味する英単語のPodで表現されています。状態は保持しないので、起動と削除しかありません。IPはエフェメラルなため、Podへのアクセスはservice名を利用します。  

- ポッド内部のコンテナを外部に公開できる
- ポッド内部のコンテナはlocalhostのIPアドレスとポート番号で互いに通信できる
- ポッド内部のコンテナは、ポッドのボリュームをコンテナからクロスマウントして、ポッド内でファイルシステムを共有できる
- ポッドは内部のコンテナの監視設定できる
- ポッドの起動後、初期化専用コンテナ(initContainers)をほかのコンテナ起動前に実行できる。<br>正常終了するとポッド内の他コンテナが起動される
- 活性プローブ(livenessProbe)が問題を検知すると、コンテナを強制終了して再び起動することで回復を試みる
- 準備状態プローブ(readinessProbe)は真を返すまで、サービスオブジェクトはポッドへリクエストを転送しない
- 削除要求があった場合、終了要求シグナル（SIGTERM）が送信<br>猶予期間過ぎて終了されていない場合、SIGKILLされる

## SideCar Pattern

コンテナをブラックボックスとして扱い、再利用性の高い複数のコンテナを組み合わせて利用するパターン。  
<https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/>

## Controller

「コントローラ」は、ポッドの実行を制御するオブジェクトであり、処理の種類に応じた複数のコントローラを使い分けなければなりません。たとえば、クライアントサーバーモデルに適した「デプロイメント」コントローラでは、サーバー役のポッドの数が、なんらかの原因で目標設定値より少なくなったら、目標値を維持するようにポッドを起動します。また、バッチ処理用の「ジョブ」コントローラでは、バッチ処理が正常終了するまで再実行を繰り返し、正常終了したらログが参照できるようにポッドの削除を保留します。  

- Deployment-ポッドの起動と停止を迅速に実行するよう振る舞い、稼働中ポッドの順次置き換え、オートスケーラーとの連動、さらに、高可用性構成が可能という特徴があり、オールラウンドに適用できます。
- StatefulSet-ポッドと永続ボリュームの組み合わせで制御を行い、永続ボリュームの保護を優先します。
- Job-バッチ処理のコンテナが正常終了するまで再試行を繰り返すコントローラです。ポッドの実行回数、同時実行数、試行回数の上限を設定して実行、削除されるまでログを保持する
- CronJob-時刻指定で定期的に前述の「ジョブ」を生成します。UNIXに実装されるcronと同じ形式で、ジョブの生成時刻を設定できます。
- DaemonSet-K8sクラスタの全ノードで、同じポッドを実行するためにあります。システム運用の自動化に適しています。
- ReplicaSet-デプロイメントコントローラと連動して、ポッドのレプリカ数の管理を担当します。

### Deployment Controller

- Scale  
Replicaの値を変更してpodの数を増減させる機能。CPU使用率と比例して自動でスケールさせるオートスケール機能がある。
podを増やす過程でk8sの計算資源が不足するとノードが増設されるまでpodの増設は保留される。
  - 水平ポッドオートスケーラ (Horizontal Pod Autoscaler: HPA)
- CPU稼働時間を監視して指定されたCPU使用率以下になるようにポッドのレプリカ数が調整される
- CPU稼働時間→例えば、200ms/sだと 1秒あたり200ミリ秒のCPU時間に相当
- nodeに1core割り当てられていたら、1000ms/s使えるので、５つのポッドが使える。
  - クラスタオートスケーラ（Cluster Autoscaler: CA）

- RollOut  
アプリケーションコンテナの更新。通常の適用と同様に`kubectl apply -f`で適用可能。進行中はリクエストの処理負荷に対処できるポッド数を残して停止できるポッド数（停止許容数）だけ古いポッドを停止する。停止許容数に加えた数だけreplicasの数を上限としてポッドを起動して新しいコンテナへの更新を行う。  
`RollingUpdateStrategy`がロールアウトの設定。`kubectl describe deployment web-deploy`で核にできる。

  - RollBack
  - ロールアウト前の古いコンテナの状態に戻すためにポッドを入れ替えていく。
  - `kubectl rollout undo deployment {resource name}`

- 自己回復機能

### CronJob Controller

ポッドが内包するすべてのコンテナが正常終了するまで再試行する。再試行回数の上限が達するとジョブが中断される。ノード障害でポッドが失われた場合、別のノードで再スタートする。ポッドはジョブが削除されるまで保持される。  

CronJobの場合、指定時刻のたびにポッドを生成して実行します。決められた保存世代数を超えるとガベージコレクションというコントローラを使って終了済みのポッドを削除する。  

### StatefulSet

ポッドと永続ボリュームの対応関係を厳密に管理し、永続ボリュームのデータ保護を優先するようにふるまう。  
ステートフルセット管理下のポッドは、レプリカセットと連携したハッシュ文字ではなく、連番を付与して命名される。  
ボリューム名もポッドとの対応付けが明確になるように末尾に連番を付与する。
ヘッドレスサービスで設定すること。IPは固定できないので、内部DNSで解決するようにする。  

### DaemonSet

すべてのノードでポッドを実行するためのコントローラ。管理下にあるpodをk8sクラスタの全ノードで稼働するように制御する。ノードが削除されると、その管理下のポッドがそのノードから削除される。ノードセレクタで一部のノードに限定できる。  

### UseCase

メッセージブローカーと合わせて利用する。ジョブを初期化するdocker containerを用意して、値をメッセージブローカーに登録する。  
そして、kubeAPIを利用して動的にmanifestを作って、JobControllerでメッセージを受け取って処理させる。  

![usecase](https://scrapbox.io/files/60d1b2f51f6ea0001c8a381f.png)  

> 高良真穂. 15Stepで習得 Dockerから入るKubernetes (Kindle の位置No.3738-3739). 株式会社リックテレコム. Kindle 版.

## Configuration

コンテナ内のアプリケーションの設定やパスワードなどの情報は、デプロイされた「名前空間」から取得することが推奨されています。それを促進するためのオブジェクトとして、設定を保存する「コンフィグマップ（ConfigMap）」と、パスワードなど秘匿情報を保存する「シークレット（Secret）」があります。  

## Service

Kubernetesの「サービス」は、ポッドとサービス名とを具体的に紐付ける役割を負います。つまり、「処理のサービス」を提供するサーバー役のポッドが、クライアントのリクエストを受け取れるようにするために、「サービス」は代表IPアドレスを取得して内部DNSへ登録するなどを担当します。さらに、代表IPアドレスへのリクエストトラフィックを該当のポット群へ転送する負荷分散の設定も担当します。  

- ロードバランサーの役割を持ち、ポッドを代表するIPアドレスを獲得して、クライアントのリクエストを受ける。
- オブジェクト生成時にサービス名と代表IPアドレスを内部DNSへ登録する。これによりクライアントは、サービスの名前からその代表IPアドレスを取得できる。
- サービスがリクエストを転送するべきポッドを選別するために、サービスのセレクターにセットされたラベルと一致するポッドを選び出し、そのIPアドレスへリクエストを転送する
- サービスのオブジェクト存在時に起動されるポッドのコンテナには、サービスへアクセスするための環境変数が自動的に設定されるようになる。

- サービスには4種のサービスタイプがあり、クライアントの範囲をK8sクラスタの内部に留めるか、外部まで対象とするか、また反対に、K8sクラスタ外部のIPアドレスへ転送するかを設定する。

| Service Type | Access Range and Method                             |
| -----------| --------------------------------------------------------------------------------------------------------------------------------|
| Cluster IP   | デフォルト。ポッドネットワーク上のポッドから内部DNSに登録された名前でアクセスできる              |
| NodePort  | CusterIP のアクセス可能範囲に加えて、K8sクラスタ外のクライアントもIPとPortを指定してアクセスできる。ノード横断でリクエストの分配が可能 |
| LoadBalancer | NodePortのアクセス可能範囲に加えて、K8sクラスタ外のクライアントも代表IPアドレスとプロトコルのデフォルトポート番号でアクセスできる |
|ExternalName|K8sクラスタ内のポッドネットワーク上のクライアントから外部のIPアドレスを名前でアクセスできる|

- セッションアフィニティ
代表IPアドレスで受けたリクエストを常にポッドに送信するキー項目。
ClientIPをセットするとクライアントのIPアドレスで転送先を固定できる

## Storage

ストレージシステムの違いを隠蔽して、コンテナが共通したAPIによって「永続ボリューム（Persistent Volume）」をアクセスできるようにしています。これを実現するためにストレージを階層的に抽象化するオブジェクト群が用意されています。
PVのプロビジョニングは、PVC（永続ボリューム要求）の作成に伴って自動的に行われる。

storage

| 種類  | 範囲 | col3 |
|:--|:--|:--|
| emptyDir | 同一ポッド内ファイル共有 | ポッドから一時的に利用する仕組み。 |
|  |  | ポッド終了とともに削除される。 |
| hostPath | 同一ノード内ファイル共有 | ポッドとともに削除されない。 <br> 外部ストレージを利用できない場合の代替手段。 |
| local | 同一ノード内ファイル共有 | ノードのディスクをコンテナからマウントして利用 |
| 外部 | ストレージシステムの方式による | NFSのようなプロトコルだとノード間で <br> 永続ボリュームを共有できる |

## 認証

Roll-Based Access Control(RBAC) 。クラスタ内で役割の権限を定義できるアクセスコントロールのこと。サービスアカウントが対応しており、サービスアカウントはユーザ個人でなく、コンテナに対して特権を付与する。namespace内で一意である。  

TODO:よくわからん。podに与える権限をコントロールしてる感じ？
<https://kubernetes.io/ja/docs/reference/access-authn-authz/authentication/>

## Ingress

リバースプロキシ。
k8sクラスタの外部からのリクエストをK8sクラスタ内部のアプリケーションへつなぐためのAPIオブジェクト。
SSL/TLS暗号化やセッションアフィニティなどの機能を備えている。

- 公開用URLとアプリケーションの対応付け
- パス部分に複数のアプリケーションを紐づけることができる！
- ingress→Serviceに転送される
- 「仮想ホスト」機能で、１つのパブリックIPアドレスを共有して、ドメイン名によって転送先を設定できる

metadataのannotation

- kubernetes.io/ingress.class:'nginx'： 複数のingressが動いている場合の送り先設定
- nginx.ingress.kubernetes.io/rewrite-target:/ : URLパスの書き換え要求

## 名前空間（namespace）

論理的にクラスタを区分することができる。名前空間を利用して論理的にコマンドの有効範囲を制限できる。  
名前空間は、１つの物理的なk8sをカオス化して、複数の占有環境としての利用を設定できる。  

- スコープ設定
- リソースの割り当て
- アクセス制御(Calico)

- default: デフォルトの名前空間
- kube-public: すべてのユーザーが読める空間
- kube-system: システムやアドオンによって利用される名前空間

## シークレット

- パスワード、トークンまたはキーなどの機密情報を保持できる
- Base64エンコーディングする必要がある
- 名前空間やサービスアカウントを作成した際のトークンを保存したシークレットが名前空間に自動生成される
- ポッドの環境変数やボリューム、ファイルとして利用できる
- tls証明書の設定とかもできるよ
- 暗号化機能を有効にできる
- ポッドを起動する前にシークレットを生成する必要がある

## コンフィグマップ

- Base64エンコードする必要がない
- シークレットと異なり定期的に更新チェックされており自動更新されて反映される

## アプリケーションの実装

- ヘルスチェック  
KubernetesのチェックするAPIに対応するコマンドやHTTPのアクセスパスを実装することでヘルスチェック苦悩を活かせる。
- コンテナの終了  
SGTERMをアプリケーションが受け取るとコンテナを停止するための終了処理を開始するように実装する必要がある。
- 稼働ログ  
DockerやKubernetesは集中型ロギング死すt無へ接続できる。そのため、アプリケーションのログは一貫して標準出力や標準エラー出力へ書き出すように実装する。

- 終了ステータス  
プロセス「PID=1」のExitコードがコンテナの終了コードとしてセットされる。
終了コード＝０で終了すると、正常終了。０以外で終了すると失敗終了として扱う。  
アプリケーションはこの終了コードを実装する必要がある。

### Skaffold

kubernatesを用いた継続的な開発体験を実現するデプロイツール  
[Kubernetesのアプリケーション開発で楽をしたい。そうだ、Skaffoldを使ってみよう！ | Skyarch Broadcasting](https://www.skyarch.net/blog/?p=16368)
